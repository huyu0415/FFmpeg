1.  ldd 工具，查看可执行程序依赖那些动态库或着动态库依赖于那些动态库  

        ldd /bin/lnlibc.so.6

2.  nm 工具，查看静态库和动态库中有那些函数名（T类表示函数是当前库中定义的，U类表示函数是被调用的，在其它库中定义的，W类是当前库中定义，被其它库中的函数覆盖）
	
	    nm libhello.so | grep printf
	    查看hello库中是否引用了 printf()
	    
3.  ar工具，可以生成静态库，同时可以查看静态库中包含那些.o文件，即有那些源文件构成
	
	    ar -t libname.a 来查看一个静态库由那些.o文件构成
	    ar q libname.a xxx1.o xxx2.o xxx3.o ... xxxn.o 生成静态库
	     
	    ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files...
	      选项前可以有‘-'字符，也可以没有
	        {dmpqrtx}中的操作选项在命令中只能并且必须使用其中一个
		    d：从库中删除模块。如果使用了任选项v则列出被删除的每个模块。
		    m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用'a'，'b'，或'i'任选项移动到指定的位置。
		    p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。
		    q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。'a'，'b'，或'i'任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用'ar s'或ranlib来更新库的符号表索引。
		    r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。
		    t：显示库的模块表清单。一般只显示模块名。
		    x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。
          任选项：
            a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。
            b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。
            c：创建一个库。不管库是否存在，都将创建。
            f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。
            i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。
            l：暂未使用
            N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。
            o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。
            P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。
            s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。
            S：不创建目标文件索引，这在创建较大的库时能加快时间。
            u：一般说来，命令ar r...插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。
            v：该选项用来显示执行操作选项的附加信息。
            V：显示ar的版本。

#### gcc 源文件 -I头文件目录 -L动态链接库目录 -l动态链接库文件名（去掉lib和.so）-o 生成的可执行文件名字
4.  生成 .so   

    	gcc test1.c test2.c -shared -fPIC -o libtest.so
	    或者
	    gcc test1.o test2.o -shared -fPIC -o libtest.so

5.  生成 .a

    	gcc -c test1.c -o test1.o
	    gcc -c test2.c -o test2.o
	    ar rcs -o libtest.a test1.o test2.o
	
6.  动态链接

    	gcc usehello.c -I/home/huyu/include -L/home/huyu/lib -lhello -o usehello  
	      
	    执行时需要将链接的 so 库 加入到动态库环境变量中或者临时扩展环境变量
	        export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/huyu/lib
	    或者
	        sudo gedit /etc/ld.so.conf.d/libc.conf
	        在末尾添加  /home/huyu/lib
	        执行 ldconfig 刷新环境变量

7.  静态链接

    	gcc usehello.c -I/home/huyu/include -L/home/huyu/lib -static -lhello -o usehello
	    LIBRARY_PATH  静态库环境变量




